#!/usr/bin/env node

/**
 * üîç SCRIPT DE VERIFICACI√ìN DE CORRECCIONES DE INTEGRACI√ìN
 * Verifica que las correcciones aplicadas funcionen correctamente
 * 
 * Uso: node scripts/verify-integration-fixes.js
 */

const fs = require('fs');
const path = require('path');

// Colores para output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function readFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch (error) {
    return null;
  }
}

function checkFileExists(filePath) {
  return fs.existsSync(filePath);
}

// 1. VERIFICAR CREDENCIALES HARDCODEADAS
function verifySupabaseClient() {
  log('\nüîç VERIFICANDO CREDENCIALES HARDCODEADAS', 'bold');
  
  const filePath = 'lib/supabase/client.ts';
  const content = readFile(filePath);
  
  if (!content) {
    log('‚ùå Archivo no encontrado', 'red');
    return false;
  }
  
  // Verificar que no hay credenciales hardcodeadas
  const hasHardcodedUrl = content.includes("'https://fwyxmovfrzauebiqxchz.supabase.co'");
  const hasHardcodedKey = content.includes("'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9");
  const hasEnvVars = content.includes('process.env.NEXT_PUBLIC_SUPABASE_URL') && 
                     content.includes('process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY');
  
  if (hasHardcodedUrl || hasHardcodedKey) {
    log('‚ùå Credenciales hardcodeadas encontradas', 'red');
    return false;
  }
  
  if (!hasEnvVars) {
    log('‚ùå Variables de entorno no encontradas', 'red');
    return false;
  }
  
  log('‚úÖ Credenciales hardcodeadas corregidas', 'green');
  return true;
}

// 2. VERIFICAR MIDDLEWARE DE AUTENTICACI√ìN
function verifyMiddleware() {
  log('\nüîç VERIFICANDO MIDDLEWARE DE AUTENTICACI√ìN', 'bold');
  
  const filePath = 'middleware.ts';
  const content = readFile(filePath);
  
  if (!content) {
    log('‚ùå Archivo no encontrado', 'red');
    return false;
  }
  
  // Verificar mejoras en el middleware
  const hasAuthCheck = content.includes('authorization') || content.includes('cookie');
  const hasRedirect = content.includes('NextResponse.redirect');
  const hasCorsFix = content.includes('NEXT_PUBLIC_SITE_URL');
  
  if (!hasAuthCheck) {
    log('‚ùå Validaci√≥n de autenticaci√≥n no implementada', 'red');
    return false;
  }
  
  if (!hasRedirect) {
    log('‚ùå Redirecci√≥n de autenticaci√≥n no implementada', 'red');
    return false;
  }
  
  if (!hasCorsFix) {
    log('‚ùå Configuraci√≥n CORS espec√≠fica no implementada', 'red');
    return false;
  }
  
  log('‚úÖ Middleware de autenticaci√≥n mejorado', 'green');
  return true;
}

// 3. VERIFICAR CONFIGURACI√ìN CORS
function verifyCorsConfig() {
  log('\nüîç VERIFICANDO CONFIGURACI√ìN CORS', 'bold');
  
  const filePath = 'next.config.js';
  const content = readFile(filePath);
  
  if (!content) {
    log('‚ùå Archivo no encontrado', 'red');
    return false;
  }
  
  // Verificar que CORS no sea demasiado permisivo
  const hasWildcardCors = content.includes("value: '*'");
  const hasSpecificCors = content.includes('NEXT_PUBLIC_SITE_URL');
  
  if (hasWildcardCors && !hasSpecificCors) {
    log('‚ùå CORS a√∫n es demasiado permisivo', 'red');
    return false;
  }
  
  if (hasSpecificCors) {
    log('‚úÖ CORS configurado espec√≠ficamente', 'green');
    return true;
  }
  
  log('‚ö†Ô∏è CORS necesita revisi√≥n manual', 'yellow');
  return false;
}

// 4. VERIFICAR SERVICIO CENTRALIZADO DE API
function verifyApiService() {
  log('\nüîç VERIFICANDO SERVICIO CENTRALIZADO DE API', 'bold');
  
  const filePath = 'lib/services/api.ts';
  
  if (!checkFileExists(filePath)) {
    log('‚ùå Servicio de API no encontrado', 'red');
    return false;
  }
  
  const content = readFile(filePath);
  
  if (!content) {
    log('‚ùå Error leyendo servicio de API', 'red');
    return false;
  }
  
  // Verificar caracter√≠sticas del servicio
  const hasApiError = content.includes('class ApiError');
  const hasAuthHeaders = content.includes('getAuthHeaders');
  const hasAttendanceMethods = content.includes('registerAttendance');
  const hasPayrollMethods = content.includes('calculatePayroll');
  
  if (!hasApiError) {
    log('‚ùå Clase ApiError no encontrada', 'red');
    return false;
  }
  
  if (!hasAuthHeaders) {
    log('‚ùå M√©todo getAuthHeaders no encontrado', 'red');
    return false;
  }
  
  if (!hasAttendanceMethods) {
    log('‚ùå M√©todos de asistencia no encontrados', 'red');
    return false;
  }
  
  if (!hasPayrollMethods) {
    log('‚ùå M√©todos de n√≥mina no encontrados', 'red');
    return false;
  }
  
  log('‚úÖ Servicio centralizado de API creado', 'green');
  return true;
}

// 5. VERIFICAR HOOK PERSONALIZADO
function verifyApiHook() {
  log('\nüîç VERIFICANDO HOOK PERSONALIZADO', 'bold');
  
  const filePath = 'lib/hooks/useApi.ts';
  
  if (!checkFileExists(filePath)) {
    log('‚ùå Hook de API no encontrado', 'red');
    return false;
  }
  
  const content = readFile(filePath);
  
  if (!content) {
    log('‚ùå Error leyendo hook de API', 'red');
    return false;
  }
  
  // Verificar caracter√≠sticas del hook
  const hasUseApi = content.includes('function useApi');
  const hasUseAttendance = content.includes('function useAttendance');
  const hasUsePayroll = content.includes('function usePayroll');
  const hasErrorHandling = content.includes('setError');
  
  if (!hasUseApi) {
    log('‚ùå Hook useApi no encontrado', 'red');
    return false;
  }
  
  if (!hasUseAttendance) {
    log('‚ùå Hook useAttendance no encontrado', 'red');
    return false;
  }
  
  if (!hasUsePayroll) {
    log('‚ùå Hook usePayroll no encontrado', 'red');
    return false;
  }
  
  if (!hasErrorHandling) {
    log('‚ùå Manejo de errores no encontrado', 'red');
    return false;
  }
  
  log('‚úÖ Hook personalizado creado', 'green');
  return true;
}

// 6. VERIFICAR COMPONENTE DE ERROR BOUNDARY
function verifyErrorBoundary() {
  log('\nüîç VERIFICANDO COMPONENTE DE ERROR BOUNDARY', 'bold');
  
  const filePath = 'components/ErrorBoundary.tsx';
  
  if (!checkFileExists(filePath)) {
    log('‚ùå Error Boundary no encontrado', 'red');
    return false;
  }
  
  const content = readFile(filePath);
  
  if (!content) {
    log('‚ùå Error leyendo Error Boundary', 'red');
    return false;
  }
  
  // Verificar caracter√≠sticas del Error Boundary
  const hasErrorBoundary = content.includes('class ErrorBoundary');
  const hasGetDerivedStateFromError = content.includes('getDerivedStateFromError');
  const hasComponentDidCatch = content.includes('componentDidCatch');
  const hasFallbackUI = content.includes('Algo sali√≥ mal');
  
  if (!hasErrorBoundary) {
    log('‚ùå Clase ErrorBoundary no encontrada', 'red');
    return false;
  }
  
  if (!hasGetDerivedStateFromError) {
    log('‚ùå getDerivedStateFromError no encontrado', 'red');
    return false;
  }
  
  if (!hasComponentDidCatch) {
    log('‚ùå componentDidCatch no encontrado', 'red');
    return false;
  }
  
  if (!hasFallbackUI) {
    log('‚ùå UI de fallback no encontrada', 'red');
    return false;
  }
  
  log('‚úÖ Error Boundary creado', 'green');
  return true;
}

// 7. VERIFICAR ESQUEMAS DE VALIDACI√ìN
function verifyValidationSchemas() {
  log('\nüîç VERIFICANDO ESQUEMAS DE VALIDACI√ìN', 'bold');
  
  const filePath = 'lib/validation/schemas.ts';
  
  if (!checkFileExists(filePath)) {
    log('‚ùå Esquemas de validaci√≥n no encontrados', 'red');
    return false;
  }
  
  const content = readFile(filePath);
  
  if (!content) {
    log('‚ùå Error leyendo esquemas de validaci√≥n', 'red');
    return false;
  }
  
  // Verificar caracter√≠sticas de validaci√≥n
  const hasValidationError = content.includes('class ValidationError');
  const hasPeriodoValidation = content.includes('validatePeriodo');
  const hasQuincenaValidation = content.includes('validateQuincena');
  const hasLast5Validation = content.includes('validateLast5');
  const hasEmailValidation = content.includes('validateEmail');
  
  if (!hasValidationError) {
    log('‚ùå Clase ValidationError no encontrada', 'red');
    return false;
  }
  
  if (!hasPeriodoValidation) {
    log('‚ùå Validaci√≥n de periodo no encontrada', 'red');
    return false;
  }
  
  if (!hasQuincenaValidation) {
    log('‚ùå Validaci√≥n de quincena no encontrada', 'red');
    return false;
  }
  
  if (!hasLast5Validation) {
    log('‚ùå Validaci√≥n de last5 no encontrada', 'red');
    return false;
  }
  
  if (!hasEmailValidation) {
    log('‚ùå Validaci√≥n de email no encontrada', 'red');
    return false;
  }
  
  log('‚úÖ Esquemas de validaci√≥n creados', 'green');
  return true;
}

// 8. VERIFICAR ENDPOINTS CR√çTICOS
function verifyCriticalEndpoints() {
  log('\nüîç VERIFICANDO ENDPOINTS CR√çTICOS', 'bold');
  
  const endpoints = [
    'pages/api/auth/login-supabase.ts',
    'pages/api/attendance/register.ts',
    'pages/api/payroll/calculate.ts',
    'pages/api/health.ts'
  ];
  
  let allExist = true;
  
  for (const endpoint of endpoints) {
    if (!checkFileExists(endpoint)) {
      log(`‚ùå Endpoint no encontrado: ${endpoint}`, 'red');
      allExist = false;
    } else {
      log(`‚úÖ Endpoint encontrado: ${endpoint}`, 'green');
    }
  }
  
  return allExist;
}

// 9. VERIFICAR COMPONENTES CR√çTICOS
function verifyCriticalComponents() {
  log('\nüîç VERIFICANDO COMPONENTES CR√çTICOS', 'bold');
  
  const components = [
    'components/PayrollManager.tsx',
    'components/AttendanceManager.tsx',
    'components/AuthForm.tsx',
    'components/ProtectedRoute.tsx'
  ];
  
  let allExist = true;
  
  for (const component of components) {
    if (!checkFileExists(component)) {
      log(`‚ùå Componente no encontrado: ${component}`, 'red');
      allExist = false;
    } else {
      log(`‚úÖ Componente encontrado: ${component}`, 'green');
    }
  }
  
  return allExist;
}

// 10. VERIFICAR VARIABLES DE ENTORNO
function verifyEnvironmentVariables() {
  log('\nüîç VERIFICANDO VARIABLES DE ENTORNO', 'bold');
  
  const envFile = '.env.local';
  const envExample = '.env.example';
  
  // Verificar si existe archivo de ejemplo
  if (!checkFileExists(envExample)) {
    log('‚ö†Ô∏è Archivo .env.example no encontrado', 'yellow');
  } else {
    log('‚úÖ Archivo .env.example encontrado', 'green');
  }
  
  // Verificar variables cr√≠ticas en archivos de configuraci√≥n
  const configFiles = [
    'lib/supabase/client.ts',
    'lib/supabase/server.ts',
    'next.config.js'
  ];
  
  let hasEnvVars = true;
  
  for (const file of configFiles) {
    const content = readFile(file);
    if (content && content.includes('process.env.')) {
      log(`‚úÖ Variables de entorno en ${file}`, 'green');
    } else {
      log(`‚ö†Ô∏è Variables de entorno no encontradas en ${file}`, 'yellow');
      hasEnvVars = false;
    }
  }
  
  return hasEnvVars;
}

// FUNCI√ìN PRINCIPAL
async function main() {
  log('üîç INICIANDO VERIFICACI√ìN DE CORRECCIONES DE INTEGRACI√ìN', 'bold');
  log('=' .repeat(70), 'blue');
  
  const results = {
    total: 0,
    passed: 0,
    failed: 0,
    details: []
  };
  
  // Ejecutar verificaciones
  const verifications = [
    { name: 'Credenciales hardcodeadas', fn: verifySupabaseClient },
    { name: 'Middleware de autenticaci√≥n', fn: verifyMiddleware },
    { name: 'Configuraci√≥n CORS', fn: verifyCorsConfig },
    { name: 'Servicio centralizado de API', fn: verifyApiService },
    { name: 'Hook personalizado', fn: verifyApiHook },
    { name: 'Error Boundary', fn: verifyErrorBoundary },
    { name: 'Esquemas de validaci√≥n', fn: verifyValidationSchemas },
    { name: 'Endpoints cr√≠ticos', fn: verifyCriticalEndpoints },
    { name: 'Componentes cr√≠ticos', fn: verifyCriticalComponents },
    { name: 'Variables de entorno', fn: verifyEnvironmentVariables }
  ];
  
  for (const verification of verifications) {
    results.total++;
    log(`\nüîç Verificando: ${verification.name}`, 'blue');
    
    try {
      const passed = verification.fn();
      if (passed) {
        results.passed++;
        log(`‚úÖ ${verification.name}: PAS√ì`, 'green');
      } else {
        results.failed++;
        log(`‚ùå ${verification.name}: FALL√ì`, 'red');
      }
      
      results.details.push({
        name: verification.name,
        passed,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      results.failed++;
      log(`‚ùå ${verification.name}: ERROR - ${error.message}`, 'red');
      results.details.push({
        name: verification.name,
        passed: false,
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  // Mostrar resumen
  log('\nüìä RESUMEN DE VERIFICACI√ìN', 'bold');
  log('=' .repeat(50), 'blue');
  log(`Total de verificaciones: ${results.total}`, 'blue');
  log(`‚úÖ Pasadas: ${results.passed}`, 'green');
  log(`‚ùå Fallidas: ${results.failed}`, 'red');
  
  const successRate = ((results.passed / results.total) * 100).toFixed(1);
  log(`üìà Tasa de √©xito: ${successRate}%`, successRate >= 80 ? 'green' : 'yellow');
  
  if (results.failed > 0) {
    log('\n‚ùå VERIFICACIONES FALLIDAS:', 'red');
    results.details
      .filter(d => !d.passed)
      .forEach(d => {
        log(`  - ${d.name}: ${d.error || 'No cumple criterios'}`, 'red');
      });
  }
  
  // Guardar reporte
  const reportPath = 'audit-reports/verification-report.json';
  const reportDir = path.dirname(reportPath);
  
  if (!fs.existsSync(reportDir)) {
    fs.mkdirSync(reportDir, { recursive: true });
  }
  
  const report = {
    timestamp: new Date().toISOString(),
    summary: {
      total: results.total,
      passed: results.passed,
      failed: results.failed,
      successRate: parseFloat(successRate)
    },
    details: results.details,
    recommendations: results.failed > 0 ? [
      'Revisar las verificaciones fallidas',
      'Ejecutar el script de correcci√≥n nuevamente',
      'Verificar manualmente los archivos problem√°ticos',
      'Actualizar variables de entorno si es necesario'
    ] : [
      'Todas las correcciones verificadas exitosamente',
      'Probar funcionalidades cr√≠ticas manualmente',
      'Implementar tests de integraci√≥n',
      'Documentar los cambios realizados'
    ]
  };
  
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  log(`\nüìÑ Reporte guardado: ${reportPath}`, 'green');
  
  // Conclusi√≥n
  if (results.failed === 0) {
    log('\nüéâ TODAS LAS VERIFICACIONES PASARON', 'bold');
    log('‚úÖ Las correcciones de integraci√≥n est√°n funcionando correctamente', 'green');
  } else {
    log('\n‚ö†Ô∏è ALGUNAS VERIFICACIONES FALLARON', 'bold');
    log('‚ùå Revisar las correcciones fallidas antes de continuar', 'red');
  }
  
  log('\nüìù PR√ìXIMOS PASOS:', 'blue');
  if (results.failed === 0) {
    log('1. Probar funcionalidades cr√≠ticas manualmente', 'yellow');
    log('2. Implementar tests de integraci√≥n', 'yellow');
    log('3. Documentar los cambios realizados', 'yellow');
    log('4. Actualizar variables de entorno en producci√≥n', 'yellow');
  } else {
    log('1. Revisar las verificaciones fallidas', 'yellow');
    log('2. Ejecutar correcciones manuales si es necesario', 'yellow');
    log('3. Volver a ejecutar este script de verificaci√≥n', 'yellow');
    log('4. No proceder hasta que todas las verificaciones pasen', 'yellow');
  }
}

// Ejecutar si es llamado directamente
if (require.main === module) {
  main().catch(error => {
    log(`\nüí• ERROR FATAL: ${error.message}`, 'red');
    process.exit(1);
  });
}

module.exports = {
  verifySupabaseClient,
  verifyMiddleware,
  verifyCorsConfig,
  verifyApiService,
  verifyApiHook,
  verifyErrorBoundary,
  verifyValidationSchemas,
  verifyCriticalEndpoints,
  verifyCriticalComponents,
  verifyEnvironmentVariables
}; 